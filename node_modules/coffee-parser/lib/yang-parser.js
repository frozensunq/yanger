// Generated by CoffeeScript 1.7.1
(function() {
  var P, YangStatement, argument, blockComment, comment, dqChar, dqLit, dqString, escape, identifier, keyword, lineComment, optSep, parse, qArg, semiOrBlock, sep, sqLit, statement, stmtBlock, uArg;

  P = require('comparse');

  YangStatement = (function() {
    function YangStatement(prf, kw, arg, substmts) {
      this.prf = prf;
      this.kw = kw;
      this.arg = arg;
      this.substmts = substmts;
    }

    return YangStatement;

  })();

  lineComment = (P.string('//')).bind(function() {
    return P.anyChar.manyTill(P.char('\n')).bind(function(cs) {
      return P.unit(cs.join(''));
    });
  });

  blockComment = (P.string('/*')).bind(function() {
    return P.anyChar.manyTill(P.string('*/')).bind(function(cs) {
      return P.unit(cs.join(''));
    });
  });

  comment = lineComment.orElse(blockComment);

  sep = (P.space.orElse(comment)).skipMany(1);

  optSep = (P.space.orElse(comment)).skipMany();

  identifier = (P.letter.orElse(P.char('_'))).bind(function(fst) {
    return (P.alphanum.orElse(P.oneOf('.-'))).many().bind(function(tail) {
      var res;
      res = fst + tail.join('');
      return P.unit(res.slice(0, 3).toLowerCase() === 'xml' ? null : res);
    });
  });

  keyword = (identifier.bind(function(prf) {
    return P.char(':').bind(function() {
      return P.unit(prf);
    });
  })).option().bind(function(pon) {
    return identifier.bind(function(kw) {
      return P.unit([pon, kw]);
    });
  });

  uArg = (P.noneOf(" '\"\n\t\r;{}/").orElse(P.char('/').notFollowedBy(P.oneOf('/*')))).concat(1);

  sqLit = P.sat(function(c) {
    return c !== "'";
  }).concat().between(P.char("'"), P.char("'"));

  escape = P.char('\\').bind(function() {
    var esc;
    esc = {
      't': '\t',
      'n': '\n',
      '"': '"',
      '\\': '\\'
    };
    return P.oneOf('tn"\\').bind(function(c) {
      return P.unit(esc[c]);
    });
  });

  dqChar = P.noneOf('"\\').orElse(escape);

  dqLit = P.char('"').bind(function() {
    return P.coordinates.bind(function(col) {
      return dqString(col[1]);
    });
  });

  dqString = function(lim) {
    var trimLead;
    trimLead = function(str) {
      var c, i, left, sptab;
      left = lim;
      sptab = '        ';
      i = 0;
      while (left > 0) {
        c = str[i++];
        if (c === ' ') {
          left -= 1;
        } else if (c === '\t') {
          if (left < 8) {
            return sptab.slice(0, 8 - left) + str.slice(i);
          }
          left -= 8;
        } else {
          return str.slice(i - 1);
        }
      }
      return str.slice(i);
    };
    return dqChar.manyTill(P.char('"')).bind(function(cs) {
      var lines, ln, mo, res, tlines, _i, _j, _len, _len1, _ref, _ref1;
      lines = cs.join('').split('\n');
      tlines = [lines[0]];
      _ref = lines.slice(1);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        ln = _ref[_i];
        tlines.push(trimLead(ln));
      }
      res = [];
      _ref1 = tlines.slice(0, -1);
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        ln = _ref1[_j];
        mo = ln.match(/(.*\S)?\s*/);
        res.push(mo[1]);
      }
      res.push(tlines.pop());
      return P.unit(res.join('\n'));
    });
  };

  qArg = dqLit.orElse(sqLit).bind(function(lft) {
    return (P.char('+').between(optSep, optSep).bind(function() {
      return qArg;
    })).option().bind(function(rt) {
      return P.unit(lft + rt);
    });
  });

  argument = uArg.orElse(qArg).option();

  statement = keyword.bind(function(kw) {
    return sep.bind(function() {
      return argument.bind(function(arg) {
        return optSep.bind(function() {
          return semiOrBlock.bind(function(sst) {
            return P.unit(new YangStatement(kw[0], kw[1], arg, sst));
          });
        });
      });
    });
  });

  stmtBlock = P.char('{').bind(function() {
    return (optSep.bind(function() {
      return statement;
    })).manyTill(optSep.bind(function() {
      return P.char('}');
    }));
  });

  semiOrBlock = (P.char(';').bind(function() {
    return P.unit([]);
  })).orElse(stmtBlock);

  parse = function(text, top) {
    var yst;
    if (top == null) {
      top = null;
    }
    yst = statement.between(optSep, optSep).parse(text);
    if ((top != null) && yst.kw !== top) {
      throw P.error("Wrong top-level statement", 0);
    }
    return yst;
  };

  module.exports = {
    parse: parse
  };

}).call(this);
